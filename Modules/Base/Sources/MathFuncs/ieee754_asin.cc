/*
    角度arcsin函数，基于GLibC中的四倍精度算法改编而来。

    License provided by GLibC:
    Quaduple expansions are
    Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>
    and are incorporated herein by permission of the author.  The author
    reserves the right to distribute this material elsewhere under different
    copying permissions.  These modifications are distributed here under the
    following terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <https://www.gnu.org/licenses/>.  
*/

#include "CSE/Base/MathFuncs.h"
#include "CSE/Base/Algorithms.h"
#include "CSE/Base/ConstLists.h"

_CSE_BEGIN

_EXTERN_C

/* arcsin(x)
 * Method :
 *	Since  asin(x) = x + x^3/6 + x^5*3/40 + x^7*15/336 + ...
 *	we approximate asin(x) on [0,0.5] by
 *		asin(x) = x + x*x^2*R(x^2)
 *      Between .5 and .625 the approximation is
 *              asin(0.5625 + x) = asin(0.5625) + x rS(x) / sS(x)
 *	For x in [0.625,1]
 *		asin(x) = pi/2-2*asin(sqrt((1-x)/2))
 *	Let y = (1-x), z = y/2, s := sqrt(z), and pio2_hi+pio2_lo=pi/2;
 *	then for x>0.98
 *		asin(x) = pi/2 - 2*(s+s*z*R(z))
 *			= pio2_hi - (2*(s+s*z*R(z)) - pio2_lo)
 *	For x<=0.98, let pio4_hi = pio2_hi/2, then
 *		f = hi part of s;
 *		c = sqrt(z) - f = (z-f*f)/(s+f) 	...f+c=sqrt(z)
 *	and
 *		asin(x) = pi/2 - 2*(s+s*z*R(z))
 *			= pio4_hi+(pio4-2s)-(2s*z*R(z)-pio2_lo)
 *			= pio4_hi+(pio4-2f)-(2s*z*R(z)-(pio2_lo+2c))
 *
 * Special cases:
 *	if x is NaN, return x itself;
 *	if |x|>1, return NaN with invalid signal.
 *
 */
__Float64 __cdecl __IEEE854_ASIN128F_C64F(__Float64 _X)
{
    __Float64 x = _X;
    __Float64 a, t, w, p, q, c, r, s;
    int flag;

    if (isnan(x)) {return x;}

    flag = 0;
    a = abs(x);
    if (a == 1.0L) {return 90;}	// |x|>= 1
    else if (a > 1.0L)
    {
        return __Float64::FromBytes(BIG_NAN_DOUBLE);
    }
    else if (a < 0.5L)
    {
        if (a < 0x1p-57L) // |x| < 2**-57
        {
            return x; // return x with inexact if x!=0
        }
        else
        {
            t = x * x;
            // Mark to use pS, qS later on.
            flag = 1;
        }
    }
    else if (a < 0.625L)
    {
        // 这里，包括下面的那些多项式都是用雷米兹算法求解得到的，所以直接转成角度系数。
        static const __Float64
            // asin(0.5625 + x) = asin(0.5625) + x rS(x) / sS(x)
            // -0.0625 <= x <= 0.0625
            // peak relative error 3.3e-35
            // converted to degrees by StellarDX
            /*rS0 = -5.619049346208901520945464704848780243887E0L,
            rS1 =  4.460504162777731472539175700169871920352E1L,
            rS2 = -1.317669505315409261479577040530751477488E2L,
            rS3 =  1.626532582423661989632442410808596009227E2L,
            rS4 = -3.144806644195158614904369445440583873264E1L,
            rS5 = -9.806674443470740708765165604769099559553E1L,
            rS6 =  5.708468492052010816555762842394927806920E1L,
            rS7 =  1.396540499232262112248553357962639431922E1L,
            rS8 = -1.126243289311910363001762058295832610344E1L,
            rS9 = -4.956179821329901954211277873774472383512E-1L,
            rS10 =  3.313227657082367169241333738391762525780E-1L,*/
            rS0 = -1011.42888231760227377018364687278044389966L,
            rS1 = +8028.9074929999166505705162603057694566336L,
            rS2 = -23718.051095677366706632386729553526594784L,
            rS3 = +29277.586483625915813383963394554728166086L,
            rS4 = -5660.6519595512855068278650017930509718752L,
            rS5 = -17652.0139982473332757772980885843792071954L,
            rS6 = +10275.243285693619469800373116310870052456L,
            rS7 = +2513.7728986180718020473960443327509774596L,
            rS8 = -2027.2379207614386534031717049324986986192L,
            rS9 = -89.211236783938235175803001727940502903216L,
            rS10 = +59.63809782748260904634400729105172546404L,

            /*sS0 = -4.645814742084009935700221277307007679325E0L,
            sS1 =  3.879074822457694323970438316317961918430E1L,
            sS2 = -1.221986588013474694623973554726201001066E2L,
            sS3 =  1.658821150347718105012079876756201905822E2L,
            sS4 = -4.804379630977558197953176474426239748977E1L,
            sS5 = -1.004296417397316948114344573811562952793E2L,
            sS6 =  7.530281592861320234941101403870010111138E1L,
            sS7 =  1.270735595411673647119592092304357226607E1L,
            sS8 = -1.815144839646376500705105967064792930282E1L,
            sS9 = -7.821597334910963922204235247786840828217E-2L,
            sS10 = 1.000000000000000000000000000000000000000E0;*/
            sS0 = -14.5952574636702856448060361136303137019576L,
            sS1 = +121.8647296495822399328155775693910968304904L,
            sS2 = -383.8984087688389392734477154368191004924278L,
            sS3 = +521.1340339551761092314940733385193225464266L,
            sS4 = -150.9340375373553866392783245200875319645678L,
            sS5 = -315.5090246921959542501601304697638172627817L,
            sS6 = +236.5707733159557006516050875761556773582279L,
            sS7 = +39.9213361120036570227223148798915033412032L,
            sS8 = -57.0244569343447968594080214679151754208322L,
            sS9 = -0.24572272726693789889252807126981941027009L,
            sS10 = 3.14159265358979323846264338327950288419717L;

        // 这里为了照顾一下某些特殊角，所以用了一个骚办法，就是把arcsin(0.5625)的值
        // 计算到104位，然后砍一半，前52位作基础数值，后52位作补偿精度。这样修改就可
        // 以使得输入0.5时能够正确返回30。
        // __Float64 asinr5625 =
        //     34.2288663278125780154415065607771622253521534461856151101724932205845765801418179349873510969541267L;
        __Float64 
            asinr5625hi = 0x1.11d4b7de88e29p+5L, // 0x1.11d4b7de88e296114f8b7f684fp+5L,
            asinr5625lo = 0x0.6114f8b7f684fp-47L; // 0x0.1dacb43b08b7409e899af01cf2p-104L;

        t = a - 0.5625;
        p = ((((((((((rS10.x * t
                      + rS9.x) * t
                     + rS8.x) * t
                    + rS7.x) * t
                   + rS6.x) * t
                  + rS5.x) * t
                 + rS4.x) * t
                + rS3.x) * t
               + rS2.x) * t
              + rS1.x) * t
             + rS0.x) * t;

        q = (((((((((sS10.x * t
                     + sS9.x) * t
                    + sS8.x) * t
                   + sS7.x) * t
                  + sS6.x) * t
                 + sS5.x) * t
                + sS4.x) * t
               + sS3.x) * t
              + sS2.x) * t
             + sS1.x) * t
            + sS0.x;

        t = asinr5625hi + (p / q + asinr5625lo);
        if (x > 0.0L) {return t;}
        else {return -t;}
    }
    else
    {
        // 1 > |x| >= 0.625
        w = 1.0L - a;
        t = w * 0.5;
    }

    // asin(x) = x + x^3 pS(x^2) / qS(x^2)
    // 0 <= x <= 0.5
    // peak relative error 1.9e-35
    // converted to degrees by StellarDX
    static const __Float64
        /*pS0 = -8.358099012470680544198472400254596543711E2L,
        pS1 =  3.674973957689619490312782828051860366493E3L,
        pS2 = -6.730729094812979665807581609853656623219E3L,
        pS3 =  6.643843795209060298375552684423454077633E3L,
        pS4 = -3.817341990928606692235481812252049415993E3L,
        pS5 =  1.284635388402653715636722822195716476156E3L,
        pS6 = -2.410736125231549204856567737329112037867E2L,
        pS7 =  2.219191969382402856557594215833622156220E1L,
        pS8 = -7.249056260830627156600112195061001036533E-1L,
        pS9 =  1.055923570937755300061509030361395604448E-3L,*/
        pS0 = -150445.782224472249795572503204582737786798L,
        pS1 = +661495.31238413150825630090904933486596874L,
        pS2 = -1211531.23706633633984536468977365819217942L,
        pS3 = +1195891.88313763085370759948319622173397394L,
        pS4 = -687121.55836714920460238672620536889487874L,
        pS5 = +231234.36991247766881461010799522896570808L,
        pS6 = -43393.250254167885687418219271924016681606L,
        pS7 = +3994.545544888325141803669588500519881196L,
        pS8 = -130.483012694951288818802019511098018657594L,
        pS9 = +0.19006624276879595401107162546505120880064L,

        /*qS0 = -5.014859407482408326519083440151745519205E3L,
        qS1 =  2.430653047950480068881028451580393430537E4L,
        qS2 = -4.997904737193653607449250593976069726962E4L,
        qS3 =  5.675712336110456923807959930107347511086E4L,
        qS4 = -3.881523118339661268482937768522572588022E4L,
        qS5 =  1.634202194895541569749717032234510811216E4L,
        qS6 = -4.151452662440709301601820849901296953752E3L,
        qS7 =  5.956050864057192019085175976175695342168E2L,
        qS8 = -4.175375777334867025769346564600396877176E1L,
        qs9 =  1.000000000000000000000000000000000000000E0;*/
        qS0 = -15754.6454733323973957122801577592449886221741L,
        qS1 = +76361.2175886686762494938136773118090037822340L,
        qS2 = -157013.8080570920843186674328750290776060290209L,
        qS3 = +178307.7617901357482760502917179520524022049450L,
        qS4 = -121941.6451331482548970782474055473506041747737L,
        qS5 = +51339.9760996414890281199944389245470587138627L,
        qS6 = -13042.1731860495201001263105407568565718105918L,
        qS7 = +1871.1485638929214746528741248821897077028979L,
        qS8 = -131.1732986805199057040174904947681623872928L,
        qS9 = +3.14159265358979323846264338327950288419717L;

    static const __Float64
        R2D = 57.2957795130823208767981548141051703324054724665643215491602438612028471483215526324409689958511109442,
        R2DM2 = 114.5915590261646417535963096282103406648109449331286430983204877224056942966431052648819379917022218884;

    p = (((((((((pS9.x * t
                 + pS8.x) * t
                + pS7.x) * t
               + pS6.x) * t
              + pS5.x) * t
             + pS4.x) * t
            + pS3.x) * t
           + pS2.x) * t
          + pS1.x) * t
         + pS0.x) * t;

    q = ((((((((qS9.x * t
                + qS8.x) * t
               + qS7.x) * t
              + qS6.x) * t
             + qS5.x) * t
            + qS4.x) * t
           + qS3.x) * t
          + qS2.x) * t
         + qS1.x) * t
        + qS0.x;

    if (flag) // 2^-57 < |x| < 0.5
    {
        w = p / q;
        return R2D.x * x + x * w;
    }

    s = __IBM_SQRT64F(t);
    if (a > 0.975L)
    {
        w = p / q;
        t = 90 - (2.0 * (R2D.x * s + s * w));
    }
    else
    {
        // 丹霞：这里确实是有些回天乏术了，试了各种办法还是没法在
        // 输入sqrt(3)/2时正确返回60，所以直接放弃这里的修正了，
        // 毕竟sqrt(3)/2本身就没法用浮点精确表示。
        w = s;
        w.parts.lsw = 0;
        c = ((t - w * w) * 180) / ((s + w) * CSE_PI);
        r = p / q;
        p = 2.0 * s * r + (2.0 * c);
        q = 45 - R2DM2.x * w;
        t = 45 - (p - q);
    }

    if (x > 0.0L) {return t;}
    else {return -t;}
}

_END_EXTERN_C

_CSE_END
