// nth-root function by StellarDX, only for real roots

#include "CSE/Base/CSEBase.h"
#include "CSE/Base/MathFuncs.h"
#include "CSE/Base/ConstLists.h"
#include "CSE/Base/Algorithms.h"
#include <cmath>

_CSE_BEGIN

float64 __cdecl yroot(float64 _X, float64 _Expo)
{
    // Special returns
    if (_Expo == 1) { return _X; }
    if (_Expo == 2) { return _CSE sqrt(_X); }
    if (_Expo == 3) { return _CSE cbrt(_X); }
    if (_Expo == -1) { return 1. / _X; }
    if (_Expo == -2) { return inversesqrt(_X); }
    if (_Expo == -3) { return 1. / _CSE cbrt(_X); }

    __Float64 Exp = _Expo;

    // Every positive real number x has a single positive nth root
    if (_X > 0 && _Expo != 0) {return _CSE pow(_X, 1. / _Expo);}

    // For even values of n, positive numbers also have a negative
    // nth root, while negative numbers do not have a real nth root.
    // For odd values of n, every negative number x has a real
    // negative nth root.
    if (_X < 0 && _Expo != 0)
    {
        if (CheckInt(Exp.Bytes) == 1) {return -yroot(-_X, _Expo);}
        else {return __Float64::FromBytes(BIG_NAN_DOUBLE);}
    }

    // The only root of 0 is 0.
    if (_X == 0 && _Expo != 0) {return 0;}

    // positive number's 0-th root is infinity, negative number's
    // 0-th root is undefined.
    if (Exp == 0)
    {
        if (_X > 0) {return __Float64::FromBytes(POS_INF_DOUBLE);}
        if (_X == 0) {return 0;}
        if (_X < 0) {return __Float64::FromBytes(BIG_NAN_DOUBLE);}
    }

    return __Float64::FromBytes(BIG_NAN_DOUBLE); // StellarDX: (maybe) unreachable, to make the compiler happy (*￣3￣)╭
}

complex64 __cdecl yrootc(complex64 _X, complex64 _Expo, int64 _K)
{
    float64 XReal = _X.real(), XImag = _X.imag();
    float64 EReal = _Expo.real(), EImag = _Expo.imag();
    int XRCls = FPClassify(XReal);
    int XICls = FPClassify(XImag);
    int ERCls = FPClassify(EReal);
    int EICls = FPClassify(EImag);

    // 处理 NaN 或 Inf 输入
    if (XRCls == Nan || XICls == Nan || ERCls == Nan || EICls == Nan)
    {
        return {__Float64::FromBytes(BIG_NAN_DOUBLE),
            __Float64::FromBytes(BIG_NAN_DOUBLE)};
    }

    // 处理 _X = 0 或 _X = -0
    if (XRCls == Zero && XICls == Zero)
    {
        if (EReal > 0)
        {
            // 0^z (Re(z)>0) = 0，保留符号位
            return {::copysign(0.0, XReal), ::copysign(0.0, XImag)};
        }
        else
        {
            // 0^z (Re(z)<=0) 未定义
            return {__Float64::FromBytes(BIG_NAN_DOUBLE),
                __Float64::FromBytes(BIG_NAN_DOUBLE)};
        }
    }

    // 处理 _Expo = 0 或 _Expo = -0
    if (ERCls == Zero && EICls == Zero)
    {
        // z^0 = 1（主值）
        return {1.0, 0.0};
    }

    // 处理 _X 为无穷大
    if (XRCls == Inf || XICls == Inf)
    {
        if (EReal > 0)
        {
            // (+∞)^z (Re(z)>0) = +∞ + i*NaN
            return {__Float64::FromBytes(POS_INF_DOUBLE),
                __Float64::FromBytes(BIG_NAN_DOUBLE)};
        }
        else if (EReal < 0)
        {
            // (+∞)^z (Re(z)<0) = 0
            return {0.0, 0.0};
        }
        else
        {
            // (+∞)^(iy) 振荡无定义
            return {__Float64::FromBytes(BIG_NAN_DOUBLE),
                __Float64::FromBytes(BIG_NAN_DOUBLE)};
        }
    }

    // 处理 _Expo 为无穷大
    if (ERCls == Inf || EICls == Inf)
    {
        // 若 _X 的模不为 1，则结果未定义
        // 模为 1 时，结果可能振荡或发散
        return {__Float64::FromBytes(BIG_NAN_DOUBLE),
            __Float64::FromBytes(BIG_NAN_DOUBLE)};
    }

    complex64 lnx = lnc(_X, _K);

    float64 LnXReal = lnx.real();
    float64 LnXImag = lnx.imag();
    float64 ExpoReal = _Expo.real();
    float64 ExpoImag = _Expo.imag();

    float64 YReal = __GLIBC_X2Y2M164F_ME(ExpoReal, LnXReal, ExpoImag, LnXImag, 0);
    float64 YImag = __GLIBC_X2Y2M164F_ME(ExpoReal, LnXImag, -ExpoImag, LnXReal, 0);
    float64 Scale = __GLIBC_X2Y2M164F_MS(ExpoReal, ExpoImag, 0);

    YReal /= Scale;
    YImag /= Scale;

    return expc({YReal, YImag});
}

_CSE_END

#if 0 // Test program generated by Deepseek
#include <iostream>
#include <complex>
#include <cmath>
#include <limits>

#include <CSE/Base.h>

using namespace cse;

// 辅助函数：比较两个复数是否接近
bool is_close(complex64 a, complex64 b, double tol = 1e-10)
{
    return abs(a.real() - b.real()) < tol && abs(a.imag() - b.imag()) < tol;
}

// 辅助函数：打印复数
void print_complex(const std::string& name, complex64 c)
{
    std::cout << name << ": (" << c.real() << ", " << c.imag() << "i)" << '\n';
}

int main()
{
    // 测试用例数组：{x, n, k}
    std::pair<complex64, std::pair<complex64, int64_t>> test_cases[] =
    {
        // 基本测试
        {{1.0, 0.0}, {{2.0, 0.0}, 0}},    // √1
        {{1.0, 0.0}, {{3.0, 0.0}, 0}},    // ³√1
        {{1.0, 0.0}, {{0.5, 0.0}, 0}},    // 1^2
        {{4.0, 0.0}, {{2.0, 0.0}, 0}},    // √4
        {{-1.0, 0.0}, {{2.0, 0.0}, 0}},   // √-1
        {{0.0, 1.0}, {{2.0, 0.0}, 0}},    // √i

        // 边界值测试
        {{0.0, 0.0}, {{2.0, 0.0}, 0}},    // √0
        {{1.0, 0.0}, {{0.0, 0.0}, 0}},    // 1^∞ (应该处理为1)
        {{0.0, 0.0}, {{0.0, 0.0}, 0}},    // 0^0 (未定义，但应处理)

        // 极值测试
        {{std::numeric_limits<double>::max(), 0.0}, {{2.0, 0.0}, 0}},
        {{std::numeric_limits<double>::min(), 0.0}, {{2.0, 0.0}, 0}},
        {{0.0, std::numeric_limits<double>::max()}, {{2.0, 0.0}, 0}},
        {{0.0, std::numeric_limits<double>::min()}, {{2.0, 0.0}, 0}},
        {{1.0, 0.0}, {{std::numeric_limits<double>::max(), 0.0}, 0}},
        {{1.0, 0.0}, {{std::numeric_limits<double>::min(), 0.0}, 0}},

        // 非整数根测试
        {{2.0, 0.0}, {{3.5, 0.0}, 0}},
        {{2.0, 3.0}, {{1.5, 2.0}, 0}},

        // 复数指数测试
        {{2.0, 3.0}, {{1.0, 1.0}, 0}},
        {{1.0, 1.0}, {{2.0, 3.0}, 0}},

        // 不同分支测试 (k值变化)
        {{1.0, 0.0}, {{3.0, 0.0}, 1}},    // ³√1的不同分支
        {{1.0, 0.0}, {{3.0, 0.0}, -1}},   // ³√1的不同分支
    };

    for (const auto& test_case : test_cases) {
        complex64 x = test_case.first;
        complex64 n = test_case.second.first;
        int64_t k = test_case.second.second;

        std::cout << "\n=== 测试用例 ===\n";
        print_complex("x", x);
        print_complex("n", n);
        std::cout << "k: " << k << '\n';

        // 计算自定义函数结果
        complex64 custom_result = yrootc(x, n, k);
        print_complex("自定义函数结果", custom_result);

        // 计算标准库结果
        std::complex<double> std_x(x.real(), x.imag());
        std::complex<double> std_n(n.real(), n.imag());
        std::complex<double> std_result = pow(std_x, 1.0/std_n);
        print_complex("标准库结果", {std_result.real(), std_result.imag()});

        // 比较结果
        bool close = is_close(custom_result, {std_result.real(), std_result.imag()}, 1e-9);
        std::cout << "结果比较: " << (close ? "匹配" : "不匹配") << '\n';

        // 对于多值函数，可能需要比较不同分支
        if (n.imag() == 0 && x.imag() == 0 && n.real() == cse::floor(n.real())) {
            std::cout << "\n检查其他分支:" << '\n';
            for (int branch = -2; branch <= 2; ++branch) {
                if (branch == 0) continue;
                complex64 branch_result = yrootc(x, n, branch);
                print_complex("分支 " + std::to_string(branch), branch_result);

                // 标准库不直接支持多分支，需要手动计算
                double angle = (2 * M_PI * branch) / n.real();
                std::complex<double> rotated = std_result * std::polar(1.0, angle);
                print_complex("标准库分支 " + std::to_string(branch), {rotated.real(), rotated.imag()});

                bool branch_close = is_close(branch_result, {rotated.real(), rotated.imag()}, 1e-9);
                std::cout << "分支比较: " << (branch_close ? "匹配" : "不匹配") << '\n';
            }
        }
    }

    // 特殊案例测试
    std::cout << "\n=== 特殊案例测试 ===" << '\n';

    // NaN测试
    complex64 nan_test = {std::numeric_limits<double>::quiet_NaN(), 0.0};
    complex64 nan_result = yrootc(nan_test, {2.0, 0.0}, 0);
    print_complex("NaN输入结果", nan_result);

    // 无穷大测试
    complex64 inf_test = {std::numeric_limits<double>::infinity(), 0.0};
    complex64 inf_result = yrootc(inf_test, {2.0, 0.0}, 0);
    print_complex("Inf输入结果", inf_result);
}

#endif
