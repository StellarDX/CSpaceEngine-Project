#include "CSE/SCStream/SCSBase.h"
#include "CSE/SCStream/ISCStream.h"
#include <stack>
#include <map>
#include <set>
#include <vector>

// Text-formating header
#if USE_FMTLIB
#include <fmt/format.h>
using namespace fmt;
#else
#include <format>
#endif

using namespace std;

_CSE_BEGIN
_SC_BEGIN

/*
 * ALGORITHM:
 *
 * The SpaceEngine sc grammar can be described as a combination
 * of keys, values and sub-tables. It can roughly written as
 * this syntax below:
 *
 *     <Key> [Values] [{<Sub-table>}]
 *
 * And this syntax can be repeated in a single file. So let this
 * grammar as G_sc(S), We can get these productions:
 *
 *     S -> KTS | Є
 *     T -> VT | V | N
 *
 * Where: K = Key, V = Value, N = Sub-tables, Є = Empty.
 *
 * Keys in this productions above are identifiers(i), then a
 * new production is get:
 *
 *     K -> i
 *
 * Then, value in this grammar can be a number, a string or a
 * boolean, which can all be viewed as expressions(E). It also
 * can be another complex types such as arrays and matrices,
 * for parsing these types we need extra productions.
 * value productions is showed below:
 *
 *     V -> E | (A) | {M}
 *     E -> n | s | b
 *     A -> E | ACE
 *     C -> , | Є
 *     M -> VCM | VC
 *
 * Contents of sub-tables are same as main table:
 *
 *     N -> {S}
 *
 * Now, all productions of G_sc(S) are found, Then we need to
 * recognize its type such as LL(1), LR(0), SLR(1) or LR(1).
 * Obviously, if we use LL(1), LR(0) or SLR(1) method, there
 * occurs conflicts. So this grammar is an LR(1) grammar at least.
 *
 * This program is originaly generated by GNU Bison and converted
 * to C++ format by StellarDX.
 *
 */

#define LALR1 0
#define LR1   1
#define IELR1 2

#if (SC_PARSER_LR == LALR1)

/*
    Skeleton implementation for Bison's Yacc-like parsers in C

    Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
    Free Software Foundation, Inc.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

/* C LALR(1) parser skeleton written by Richard Stallman, by
   simplifying the original so-called "semantic" parser.  */

using SCSTYPE       = int;
using scstype       = SCSTYPE;
using sctype_uint8  = unsigned char;
using sctype_int8   = signed char;
using sctype_uint16 = unsigned short int;
using sctype_int16  = short int;
using SCSIZE_T      = size_t;

#define SCFINAL    4  // State number of the termination state.
#define SCLAST     36 // Last index in SCTABLE.
#define SCNTOKENS  12 // Number of terminals.
#define SCNNTS     10 // Number of non-terminals.
#define SCNRULES   20 // Number of rules.
#define SCNSTATES  30 // Number of states.

// Bison symbol number corresponding to YYLEX.
#define SCUNDEFTOK 2
#define SCMAXUTOK  261

#define SCTRANSLATE(_Xx)\
((unsigned int)(_Xx) <= SCMAXUTOK ? sctranslate[_Xx] : SCUNDEFTOK)

_EXTERN_C

static const sctype_uint8 sctranslate[] =
{
    0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    7,     8,     2,     2,    11,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     9,     2,    10,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
    5,     6
};

// Index of the first RHS symbol of rule number YYN in YYRHS.
static const sctype_uint8 scprhs[] =
{
     0,     0,     3,     7,     8,    11,    13,    15,    17,    19,
    23,    27,    29,    31,    33,    35,    39,    41,    42,    46,
    49
};

// A `-1'-separated list of the rules' RHS.
static const sctype_int8 scrhs[] =
{
    13,     0,    -1,    15,    14,    13,    -1,    -1,    16,    14,
    -1,    16,    -1,    21,    -1,     3,    -1,    17,    -1,     7,
    18,     8,    -1,     9,    20,    10,    -1,     4,    -1,     5,
    -1,     6,    -1,    17,    -1,    18,    19,    17,    -1,    11,
    -1,    -1,    16,    19,    20,    -1,    16,    19,    -1,     9,
    13,    10,    -1
};

// source line where rule number YYN was defined.
static const sctype_uint8 scrline[] =
{
     0,     9,     9,     9,    10,    10,    10,    12,    14,    14,
    14,    15,    15,    15,    16,    16,    17,    17,    18,    18,
    20
};

// String name of the symbol SYMBOL-NUM. First, the terminals,
// then, starting at YYNTOKENS, nonterminals.
static const char *const sctname[] =
{
    "$end", "error", "$undefined", "Identifier", "Number", "String",
    "Boolean", "'('", "')'", "'{'", "'}'", "','", "$accept", "Table",
    "ValueOrSubTable", "Key", "Value", "Expression", "Array", "Comma",
    "Matrix", "SubTable", 0
};

// Internal token number corresponding to token YYLEX-NUM.
static const sctype_uint16 sctoknum[] =
{
      0,   256,   257,   258,   259,   260,   261,    40,    41,   123,
    125,    44
};

// Symbol number of symbol that rule YYN derives.
static const sctype_uint8 scr1[] =
{
     0,    12,    13,    13,    14,    14,    14,    15,    16,    16,
    16,    17,    17,    17,    18,    18,    19,    19,    20,    20,
    21
};

// Number of symbols composing right hand side of rule YYN.
static const sctype_uint8 scr2[] =
{
    0,     2,     3,     0,     2,     1,     1,     1,     1,     3,
    3,     1,     1,     1,     1,     3,     1,     0,     3,     2,
    3
};

// Default rule to reduce with in state STATE-NUM when SCTABLE
// doesn't specify something else to do. Zero means the default
// is an error.
static const sctype_uint8 scdefact[] =
{
    3,     7,     0,     0,     1,    11,    12,    13,     0,     3,
    3,     5,     8,     6,    14,    17,     0,     0,    17,     0,
    2,     4,     9,    16,     0,    20,    19,    10,    15,    18
};

static const sctype_int8 scdefgoto[] =
{
    -1,     2,    10,     3,    18,    12,    15,    24,    19,    13
};

// Index in SCTABLE of the portion describing STATE-NUM.
#define SCPACT_NINF -9
static const sctype_int8 scpact[] =
{
     4,    -9,    14,     6,    -9,    -9,    -9,    -9,    23,    -1,
     4,     6,    -9,    -9,    -9,    15,    13,    11,    22,    24,
    -9,    -9,    -9,    -9,    23,    -9,    13,    -9,    -9,    -9
};

static const sctype_int8 scpgoto[] =
{
    -9,    21,    25,    -9,    -2,    -8,    -9,     7,     9,    -9
};

// What to do in state STATE-NUM.
// If positive, shift that token.
// If negative, reduce the rule which number is the opposite.
// If zero, do what SCDEFACT says.
// If SCTABLE_NINF, syntax error.
#define SCTABLE_NINF -1
static const sctype_uint8 sctable[] =
{
    14,    11,     1,     5,     6,     7,     8,     1,    16,    11,
     5,     6,     7,     8,     4,     9,    28,     5,     6,     7,
     8,    25,    16,    22,     0,    26,    23,     5,     6,     7,
    17,    20,     0,    23,    27,    29,    21
};

static const sctype_int8 sccheck[] =
{
    8,     3,     3,     4,     5,     6,     7,     3,     9,    11,
    4,     5,     6,     7,     0,     9,    24,     4,     5,     6,
    7,    10,     9,     8,    -1,    18,    11,     4,     5,     6,
    9,    10,    -1,    11,    10,    26,    11
};

// The (internal number of the) accessing symbol of state STATE-NUM.
static const sctype_uint8 scstos[] =
{
     0,     3,    13,    15,     0,     4,     5,     6,     7,     9,
    14,    16,    17,    21,    17,    18,     9,    13,    16,    20,
    13,    14,     8,    11,    19,    10,    19,    10,    17,    20
};

#define scerrok		(yyerrstatus = 0)
#define scclearin	(yychar = YYEMPTY)
#define SCEMPTY		(-2)
#define SCEOF		0

enum __YACC_ParserState
{

};

int __YACC_LALR1_Parser(SharedPointer<TokenArrayType<char>> Symbols, SharedTablePointer& OutputTable)
{

}

// int __YACC_LALR1_Parser_WCHAR(SharedPointer<TokenArrayType<wchar_t>> Symbols, WSharedTablePointer& OutputTable)
// {

// }

_END_EXTERN_C

#elif (SC_PARSER_LR == LR1)

/*
    Skeleton implementation of SLR(1)/LR(1) Parser in C++

    Copyright (C) 2023, 2024
    StellarDX Astronomy

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

/* C++ SLR(1)/LR(1) parser skeleton written by StellarDX. */

// Definations from YACC Parser
#define SCFINAL    4   // State number of the termination state.
#define SCLAST     315 // Last index in TABLE. (Unused)
#define SCNTOKENS  12  // Number of terminals.
#define SCNNTS     10  // Number of nonterminals.
#define SCNRULES   20  // Number of rules.
#define SCNSTATES  61  // Number of states.

struct __SC_Parser_Base
{
public:
    using GrammaValueType       = pair<char, string>;
    using GrammaTableType       = vector<GrammaValueType>;
    using TerminatesType        = set<char>;
    using ProductionType        = pair<char, string>;

    using ProductionIterator    = size_t;

    struct ItemCollectionType
    {
        using ActionShiftType   = map<char, size_t>;
        using ActionReduceType  = map<char, size_t>;
        using GotoType          = map<char, size_t>;

        bool             IsAccept = 0;
        ActionShiftType  Shifts;
        ActionReduceType Reduces;
        GotoType         Gotos;
        string           ErrorMessage;
    };

    using ItemCollectionSetType = vector<struct ItemCollectionType>;

    static const GrammaTableType       SCGrammar;
    static const ItemCollectionSetType ItemCollections;
};

#include "ISCLR1States.tbl"

int __StelCXX_LR1_Parser(SharedPointer<TokenArrayType<char>> Symbols, SharedTablePointer& OutputTable)
{

}

// int __StelCXX_LR1_Parser_WCHAR(SharedPointer<TokenArrayType<wchar_t>> Symbols, WSharedTablePointer& OutputTable)
// {

// }

#elif (SC_PARSER_LR == IELR1)
#error IELR(1) algorithom is deprecated because its parsing table is same as LALR(1), use LALR(1) instead.
#else
#error Invalid parser option.
#endif

_SC_END
_CSE_END
